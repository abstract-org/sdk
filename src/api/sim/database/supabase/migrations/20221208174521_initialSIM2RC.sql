-- This script was generated by the Schema Diff utility in pgAdmin 4
-- For the circular dependencies, the order in which Schema Diff writes the objects is not very sophisticated
-- and may require manual changes to the script to ensure changes are applied in the correct order.
-- Please report an issue for any failure with the reproduction steps.

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
begin
  insert into public.user (id, email)
  values (new.id, new.email);
  return new;
end;
$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO supabase_admin;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

CREATE TABLE IF NOT EXISTS public.snapshot_investor
(
    id bigint NOT NULL DEFAULT nextval('snapshot_investor_id_seq'::regclass),
    created_at timestamp(6) with time zone DEFAULT CURRENT_TIMESTAMP,
    snapshot_id integer NOT NULL,
    entity_id integer NOT NULL,
    CONSTRAINT snapshot_investor_pkey PRIMARY KEY (snapshot_id, entity_id),
    CONSTRAINT snapshot_investor_entity_id_fkey FOREIGN KEY (entity_id)
        REFERENCES public.investor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT snapshot_investor_snapshot_id_fkey FOREIGN KEY (snapshot_id)
        REFERENCES public.snapshot (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.snapshot_investor
    OWNER to postgres;

ALTER TABLE IF EXISTS public.snapshot_investor
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.snapshot_investor TO anon;

GRANT ALL ON TABLE public.snapshot_investor TO authenticated;

GRANT ALL ON TABLE public.snapshot_investor TO postgres;

GRANT ALL ON TABLE public.snapshot_investor TO service_role;

GRANT ALL ON TABLE public.snapshot_investor TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.snapshot_investor
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.snapshot_investor
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.snapshot_totals
(
    id bigint NOT NULL DEFAULT nextval('snapshot_totals_id_seq'::regclass),
    snapshot_id integer NOT NULL,
    quests integer NOT NULL,
    cross_pools integer NOT NULL,
    investors integer NOT NULL,
    tvl integer NOT NULL,
    mcap integer NOT NULL,
    usdc integer NOT NULL,
    CONSTRAINT snapshot_totals_pkey PRIMARY KEY (id),
    CONSTRAINT snapshot_totals_snapshot_id_fkey FOREIGN KEY (snapshot_id)
        REFERENCES public.snapshot (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.snapshot_totals
    OWNER to postgres;

ALTER TABLE IF EXISTS public.snapshot_totals
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.snapshot_totals TO anon;

GRANT ALL ON TABLE public.snapshot_totals TO authenticated;

GRANT ALL ON TABLE public.snapshot_totals TO postgres;

GRANT ALL ON TABLE public.snapshot_totals TO service_role;
CREATE POLICY "Allow read for everyone"
    ON public.snapshot_totals
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.snapshot_totals
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.position_owner
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    pool_id integer NOT NULL,
    amt1 double precision NOT NULL,
    hash text COLLATE pg_catalog."default",
    native boolean,
    pmax double precision,
    pmin double precision,
    type text COLLATE pg_catalog."default",
    amt0 double precision,
    CONSTRAINT position_owners_pkey PRIMARY KEY (id),
    CONSTRAINT position_owner_pool_id_fkey FOREIGN KEY (pool_id)
        REFERENCES public.pool (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.position_owner
    OWNER to postgres;

ALTER TABLE IF EXISTS public.position_owner
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.position_owner TO anon;

GRANT ALL ON TABLE public.position_owner TO authenticated;

GRANT ALL ON TABLE public.position_owner TO postgres;

GRANT ALL ON TABLE public.position_owner TO service_role;

GRANT ALL ON TABLE public.position_owner TO supabase_admin;
CREATE INDEX IF NOT EXISTS position_owners_owner_id_index
    ON public.position_owner USING btree
    (pool_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow read for everyone"
    ON public.position_owner
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.position_owner
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.investor_navs
(
    id bigint NOT NULL DEFAULT nextval('investor_navs_id_seq'::regclass),
    investor_id integer NOT NULL,
    day integer NOT NULL,
    usdc_nav double precision NOT NULL,
    token_nav double precision NOT NULL,
    created_at timestamp(6) with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT investor_navs_pkey PRIMARY KEY (id),
    CONSTRAINT investor_navs_investor_id_fkey FOREIGN KEY (investor_id)
        REFERENCES public.investor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.investor_navs
    OWNER to postgres;

ALTER TABLE IF EXISTS public.investor_navs
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.investor_navs TO anon;

GRANT ALL ON TABLE public.investor_navs TO authenticated;

GRANT ALL ON TABLE public.investor_navs TO postgres;

GRANT ALL ON TABLE public.investor_navs TO service_role;

GRANT ALL ON TABLE public.investor_navs TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.investor_navs
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.investor_navs
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public."position"
(
    id integer NOT NULL DEFAULT nextval('position_id_seq'::regclass),
    pool_id integer NOT NULL,
    liquidity double precision NOT NULL,
    left_point double precision NOT NULL,
    right_point double precision NOT NULL,
    price_point double precision NOT NULL,
    created_at timestamp(0) with time zone NOT NULL,
    CONSTRAINT position_pkey PRIMARY KEY (id),
    CONSTRAINT position_pool_id_foreign FOREIGN KEY (pool_id)
        REFERENCES public.pool (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."position"
    OWNER to postgres;

ALTER TABLE IF EXISTS public."position"
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public."position" TO anon;

GRANT ALL ON TABLE public."position" TO authenticated;

GRANT ALL ON TABLE public."position" TO postgres;

GRANT ALL ON TABLE public."position" TO service_role;

GRANT ALL ON TABLE public."position" TO supabase_admin;
CREATE INDEX IF NOT EXISTS position_owner_id_index
    ON public."position" USING btree
    (liquidity ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS position_pool_id_index
    ON public."position" USING btree
    (pool_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow read for everyone"
    ON public."position"
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public."position"
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.pool_data
(
    id integer NOT NULL DEFAULT nextval('pool_data_id_seq'::regclass),
    swap_id integer,
    pool_id integer NOT NULL,
    current_liquidity double precision NOT NULL,
    current_price double precision NOT NULL,
    current_price_point_lg2 double precision NOT NULL,
    current_left_lg2 double precision NOT NULL,
    current_right_lg2 double precision NOT NULL,
    token0_price double precision NOT NULL,
    volume_token0 double precision NOT NULL,
    token1_price double precision NOT NULL,
    volume_token1 double precision NOT NULL,
    tvl double precision NOT NULL,
    mcap double precision NOT NULL,
    created_at timestamp(0) with time zone NOT NULL,
    is_fresh boolean NOT NULL DEFAULT true,
    total_sold double precision NOT NULL,
    sold_token0 double precision NOT NULL,
    sold_token1 double precision NOT NULL,
    CONSTRAINT pool_data_pkey PRIMARY KEY (id),
    CONSTRAINT pool_data_pool_id_foreign FOREIGN KEY (pool_id)
        REFERENCES public.pool (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT pool_data_swap_id_fkey FOREIGN KEY (swap_id)
        REFERENCES public.swap (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.pool_data
    OWNER to postgres;

ALTER TABLE IF EXISTS public.pool_data
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.pool_data TO anon;

GRANT ALL ON TABLE public.pool_data TO authenticated;

GRANT ALL ON TABLE public.pool_data TO postgres;

GRANT ALL ON TABLE public.pool_data TO service_role;

GRANT ALL ON TABLE public.pool_data TO supabase_admin;
CREATE INDEX IF NOT EXISTS pool_data_pool_id_index
    ON public.pool_data USING btree
    (pool_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow read for everyone"
    ON public.pool_data
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.pool_data
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.investor
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    type character varying(255) COLLATE pg_catalog."default" NOT NULL,
    hash character varying(255) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp(0) with time zone NOT NULL,
    initial_balance double precision NOT NULL DEFAULT '0'::double precision,
    CONSTRAINT investor_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.investor
    OWNER to postgres;

ALTER TABLE IF EXISTS public.investor
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.investor TO anon;

GRANT ALL ON TABLE public.investor TO authenticated;

GRANT ALL ON TABLE public.investor TO postgres;

GRANT ALL ON TABLE public.investor TO service_role;

GRANT ALL ON TABLE public.investor TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.investor
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.investor
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.investor_balances
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    investor_id integer NOT NULL,
    quest_id integer NOT NULL,
    balance numeric NOT NULL,
    day integer,
    CONSTRAINT investor_balances_pkey PRIMARY KEY (id),
    CONSTRAINT investor_balances_investor_id_foreign FOREIGN KEY (investor_id)
        REFERENCES public.investor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT investor_balances_quest_id_foreign FOREIGN KEY (quest_id)
        REFERENCES public.quest (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.investor_balances
    OWNER to postgres;

ALTER TABLE IF EXISTS public.investor_balances
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.investor_balances TO anon;

GRANT ALL ON TABLE public.investor_balances TO authenticated;

GRANT ALL ON TABLE public.investor_balances TO postgres;

GRANT ALL ON TABLE public.investor_balances TO service_role;

GRANT ALL ON TABLE public.investor_balances TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.investor_balances
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.investor_balances
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.log
(
    id integer NOT NULL DEFAULT nextval('log_id_seq'::regclass),
    pool_id integer,
    investor_id integer NOT NULL,
    action character varying(255) COLLATE pg_catalog."default" NOT NULL,
    day integer,
    mcap bigint,
    op_name text COLLATE pg_catalog."default",
    total_amount_in text COLLATE pg_catalog."default",
    total_amount_out text COLLATE pg_catalog."default",
    tvl bigint,
    price text COLLATE pg_catalog."default",
    blk bigint NOT NULL DEFAULT '0'::bigint,
    CONSTRAINT log_pkey PRIMARY KEY (id),
    CONSTRAINT log_investor_id_foreign FOREIGN KEY (investor_id)
        REFERENCES public.investor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT log_pool_id_fkey FOREIGN KEY (pool_id)
        REFERENCES public.pool (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.log
    OWNER to postgres;

ALTER TABLE IF EXISTS public.log
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.log TO anon;

GRANT ALL ON TABLE public.log TO authenticated;

GRANT ALL ON TABLE public.log TO postgres;

GRANT ALL ON TABLE public.log TO service_role;

GRANT ALL ON TABLE public.log TO supabase_admin;
CREATE INDEX IF NOT EXISTS log_investor_id_index
    ON public.log USING btree
    (investor_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS log_pool_id_index
    ON public.log USING btree
    (pool_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow read for everyone"
    ON public.log
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.log
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.snapshot
(
    id integer NOT NULL DEFAULT nextval('snapshot_id_seq'::regclass),
    seed character varying(255) COLLATE pg_catalog."default" NOT NULL,
    scenario_id integer,
    created_at timestamp(3) without time zone DEFAULT CURRENT_TIMESTAMP,
    current_day bigint DEFAULT '0'::bigint,
    creator_id uuid,
    CONSTRAINT snapshot_pkey PRIMARY KEY (id),
    CONSTRAINT snapshot_creator_id_fkey FOREIGN KEY (creator_id)
        REFERENCES public."user" (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT snapshot_scenario_id_fkey FOREIGN KEY (scenario_id)
        REFERENCES public.scenario (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.snapshot
    OWNER to postgres;

GRANT ALL ON TABLE public.snapshot TO anon;

GRANT ALL ON TABLE public.snapshot TO authenticated;

GRANT ALL ON TABLE public.snapshot TO postgres;

GRANT ALL ON TABLE public.snapshot TO service_role;

GRANT ALL ON TABLE public.snapshot TO supabase_admin;
CREATE INDEX IF NOT EXISTS snapshot_scenario_id_index
    ON public.snapshot USING btree
    (scenario_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow read for everyone"
    ON public.snapshot
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.snapshot
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public."user"
(
    id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    email text COLLATE pg_catalog."default",
    CONSTRAINT user_pkey PRIMARY KEY (id),
    CONSTRAINT user_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public."user"
    OWNER to supabase_admin;

GRANT ALL ON TABLE public."user" TO anon;

GRANT ALL ON TABLE public."user" TO authenticated;

GRANT ALL ON TABLE public."user" TO postgres;

GRANT ALL ON TABLE public."user" TO service_role;

GRANT ALL ON TABLE public."user" TO supabase_admin;

COMMENT ON TABLE public."user"
    IS 'Public User Data';

CREATE TABLE IF NOT EXISTS public.scenario_quest_config
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    quest_gen_alias text COLLATE pg_catalog."default",
    quest_gen_name text COLLATE pg_catalog."default",
    initial_author_invest bigint,
    starting_price bigint,
    cite_single_name text COLLATE pg_catalog."default",
    prob_cite_single bigint,
    single_cite_perc bigint,
    cite_single_multiplier bigint,
    prob_random_cite bigint,
    random_cite_perc bigint,
    cite_random_multiplier bigint,
    cite_random_prefer_own boolean,
    scenario_id integer NOT NULL,
    CONSTRAINT scenarion_quest_config_pkey PRIMARY KEY (id),
    CONSTRAINT scenario_quest_config_scenario_id_fkey FOREIGN KEY (scenario_id)
        REFERENCES public.scenario (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.scenario_quest_config
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.scenario_quest_config
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.scenario_quest_config TO anon;

GRANT ALL ON TABLE public.scenario_quest_config TO authenticated;

GRANT ALL ON TABLE public.scenario_quest_config TO postgres;

GRANT ALL ON TABLE public.scenario_quest_config TO service_role;

GRANT ALL ON TABLE public.scenario_quest_config TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.scenario_quest_config
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.scenario_quest_config
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.quest
(
    id integer NOT NULL DEFAULT nextval('quest_id_seq'::regclass),
    author_id integer,
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    hash character varying(255) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp(3) without time zone DEFAULT CURRENT_TIMESTAMP,
    is_human boolean DEFAULT false,
    initial_balance_a double precision NOT NULL DEFAULT '0'::double precision,
    initial_balance_b double precision NOT NULL DEFAULT '0'::double precision,
    CONSTRAINT quest_pkey PRIMARY KEY (id),
    CONSTRAINT quest_author_id_fkey FOREIGN KEY (author_id)
        REFERENCES public.investor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.quest
    OWNER to postgres;

ALTER TABLE IF EXISTS public.quest
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.quest TO anon;

GRANT ALL ON TABLE public.quest TO authenticated;

GRANT ALL ON TABLE public.quest TO postgres;

GRANT ALL ON TABLE public.quest TO service_role;

GRANT ALL ON TABLE public.quest TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.quest
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.quest
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public._prisma_migrations
(
    id character varying(36) COLLATE pg_catalog."default" NOT NULL,
    checksum character varying(64) COLLATE pg_catalog."default" NOT NULL,
    finished_at timestamp with time zone,
    migration_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    logs text COLLATE pg_catalog."default",
    rolled_back_at timestamp with time zone,
    started_at timestamp with time zone NOT NULL DEFAULT now(),
    applied_steps_count integer NOT NULL DEFAULT 0,
    CONSTRAINT _prisma_migrations_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public._prisma_migrations
    OWNER to postgres;

GRANT ALL ON TABLE public._prisma_migrations TO anon;

GRANT ALL ON TABLE public._prisma_migrations TO authenticated;

GRANT ALL ON TABLE public._prisma_migrations TO postgres;

GRANT ALL ON TABLE public._prisma_migrations TO service_role;

GRANT ALL ON TABLE public._prisma_migrations TO supabase_admin;

CREATE TABLE IF NOT EXISTS public.snapshot_quest
(
    id bigint NOT NULL DEFAULT nextval('snapshot_quest_id_seq'::regclass),
    created_at timestamp(6) with time zone DEFAULT CURRENT_TIMESTAMP,
    snapshot_id integer NOT NULL,
    entity_id integer NOT NULL,
    CONSTRAINT snapshot_quest_pkey PRIMARY KEY (snapshot_id, entity_id),
    CONSTRAINT snapshot_quest_entity_id_fkey FOREIGN KEY (entity_id)
        REFERENCES public.quest (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT snapshot_quest_snapshot_id_fkey FOREIGN KEY (snapshot_id)
        REFERENCES public.snapshot (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.snapshot_quest
    OWNER to postgres;

ALTER TABLE IF EXISTS public.snapshot_quest
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.snapshot_quest TO anon;

GRANT ALL ON TABLE public.snapshot_quest TO authenticated;

GRANT ALL ON TABLE public.snapshot_quest TO postgres;

GRANT ALL ON TABLE public.snapshot_quest TO service_role;

GRANT ALL ON TABLE public.snapshot_quest TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.snapshot_quest
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.snapshot_quest
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.swap
(
    id integer NOT NULL DEFAULT nextval('swap_id_seq'::regclass),
    pool_id integer NOT NULL,
    investor_id integer NOT NULL,
    action character varying(255) COLLATE pg_catalog."default" NOT NULL,
    amount_in text COLLATE pg_catalog."default" NOT NULL,
    amount_out text COLLATE pg_catalog."default" NOT NULL,
    day integer NOT NULL,
    block integer NOT NULL,
    path character varying(255) COLLATE pg_catalog."default" NOT NULL,
    price text COLLATE pg_catalog."default",
    mcap text COLLATE pg_catalog."default",
    tvl text COLLATE pg_catalog."default",
    op_name text COLLATE pg_catalog."default",
    CONSTRAINT swap_pkey PRIMARY KEY (id),
    CONSTRAINT swap_investor_id_fkey FOREIGN KEY (investor_id)
        REFERENCES public.investor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT swap_pool_id_fkey FOREIGN KEY (pool_id)
        REFERENCES public.pool (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.swap
    OWNER to postgres;

ALTER TABLE IF EXISTS public.swap
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.swap TO anon;

GRANT ALL ON TABLE public.swap TO authenticated;

GRANT ALL ON TABLE public.swap TO postgres;

GRANT ALL ON TABLE public.swap TO service_role;

GRANT ALL ON TABLE public.swap TO supabase_admin;
CREATE INDEX IF NOT EXISTS swap_investor_id_index
    ON public.swap USING btree
    (investor_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE INDEX IF NOT EXISTS swap_pool_id_index
    ON public.swap USING btree
    (pool_id ASC NULLS LAST)
    TABLESPACE pg_default;
CREATE POLICY "Allow read for everyone"
    ON public.swap
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.swap
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.scenario
(
    id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 2147483647 CACHE 1 ),
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp(0) with time zone NOT NULL DEFAULT now(),
    CONSTRAINT scenario_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.scenario
    OWNER to postgres;

ALTER TABLE IF EXISTS public.scenario
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.scenario TO anon;

GRANT ALL ON TABLE public.scenario TO authenticated;

GRANT ALL ON TABLE public.scenario TO postgres;

GRANT ALL ON TABLE public.scenario TO service_role;

GRANT ALL ON TABLE public.scenario TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.scenario
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.scenario
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.scenario_investor_config
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    global_swap_threshold bigint,
    daily_spawn_probability bigint,
    inv_gen_alias text COLLATE pg_catalog."default",
    inv_gen_name text COLLATE pg_catalog."default",
    initial_balance bigint,
    buy_sell_period_days bigint,
    buy_single_perc bigint,
    include_single_name text COLLATE pg_catalog."default",
    buy_sum_perc bigint,
    buy_quest_perc bigint,
    buy_gainer_perc bigint,
    buy_gainers_frequency bigint,
    exclude_single_name text COLLATE pg_catalog."default",
    swap_inc_frequency bigint,
    swap_inc_dir text COLLATE pg_catalog."default",
    swap_inc_sum_perc bigint,
    swap_inc_by_perc bigint,
    swap_dec_frequency bigint,
    swap_dec_dir text COLLATE pg_catalog."default",
    swap_dec_sum_perc bigint,
    swap_dec_by_perc bigint,
    create_quest text COLLATE pg_catalog."default",
    keep_creating_quests text COLLATE pg_catalog."default",
    keep_creating_period_days bigint,
    keep_citing_probability bigint,
    keep_citing_sum_percentage bigint,
    keep_citing_price_higher_than bigint,
    keep_citing_pos_multiplier bigint,
    value_sell_period_days bigint,
    value_sell_amount bigint,
    smart_route_depth bigint,
    scenario_id integer NOT NULL,
    buy_single_amount bigint,
    buy_sum_amount bigint,
    swap_inc_sum_amount bigint,
    swap_dec_sum_amount bigint,
    value_sell_perc bigint,
    CONSTRAINT scenario_investor_config_pkey PRIMARY KEY (id),
    CONSTRAINT scenario_investor_config_scenario_id_fkey FOREIGN KEY (scenario_id)
        REFERENCES public.scenario (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.scenario_investor_config
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.scenario_investor_config
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.scenario_investor_config TO anon;

GRANT ALL ON TABLE public.scenario_investor_config TO authenticated;

GRANT ALL ON TABLE public.scenario_investor_config TO postgres;

GRANT ALL ON TABLE public.scenario_investor_config TO service_role;

GRANT ALL ON TABLE public.scenario_investor_config TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.scenario_investor_config
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.scenario_investor_config
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.snapshot_pool
(
    id bigint NOT NULL DEFAULT nextval('snapshot_pool_id_seq'::regclass),
    created_at timestamp(6) with time zone DEFAULT CURRENT_TIMESTAMP,
    snapshot_id integer NOT NULL,
    entity_id integer NOT NULL,
    CONSTRAINT snapshot_pool_pkey PRIMARY KEY (snapshot_id, entity_id),
    CONSTRAINT snapshot_pool_entity_id_fkey FOREIGN KEY (entity_id)
        REFERENCES public.pool (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT snapshot_pool_snapshot_id_fkey FOREIGN KEY (snapshot_id)
        REFERENCES public.snapshot (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.snapshot_pool
    OWNER to postgres;

ALTER TABLE IF EXISTS public.snapshot_pool
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.snapshot_pool TO anon;

GRANT ALL ON TABLE public.snapshot_pool TO authenticated;

GRANT ALL ON TABLE public.snapshot_pool TO postgres;

GRANT ALL ON TABLE public.snapshot_pool TO service_role;

GRANT ALL ON TABLE public.snapshot_pool TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.snapshot_pool
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.snapshot_pool
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));

CREATE TABLE IF NOT EXISTS public.pool
(
    id integer NOT NULL DEFAULT nextval('pool_id_seq'::regclass),
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    token0 integer NOT NULL,
    token1 integer NOT NULL,
    type character varying(255) COLLATE pg_catalog."default" NOT NULL,
    hash character varying(255) COLLATE pg_catalog."default",
    created_at timestamp(0) with time zone NOT NULL,
    CONSTRAINT pool_pkey PRIMARY KEY (id),
    CONSTRAINT pool_token0_fkey FOREIGN KEY (token0)
        REFERENCES public.quest (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT pool_token1_fkey FOREIGN KEY (token1)
        REFERENCES public.quest (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.pool
    OWNER to postgres;

ALTER TABLE IF EXISTS public.pool
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.pool TO anon;

GRANT ALL ON TABLE public.pool TO authenticated;

GRANT ALL ON TABLE public.pool TO postgres;

GRANT ALL ON TABLE public.pool TO service_role;

GRANT ALL ON TABLE public.pool TO supabase_admin;
CREATE POLICY "Allow read for everyone"
    ON public.pool
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);
CREATE POLICY "Only agora-labs.com staff can insert"
    ON public.pool
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK (("right"((auth.jwt() ->> 'email'::text), 15) ~~ '@agora-labs.com'::text));
